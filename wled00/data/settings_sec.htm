<!DOCTYPE html>
<html lang="en">
<head>
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
	<meta charset="utf-8">
	<title>安全与更新设置</title>
	<script src="common.js" type="text/javascript"></script>
	<script>
		function U() { window.open(getURL("/update"),"_self"); }
		function checkNum(o) {
			const specialkeys = ["Backspace", "Tab", "Enter", "Shift", "Control", "Alt", "Pause", "CapsLock", "Escape", "Space", "PageUp", "PageDown", "End", "Home", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "Insert", "Delete"];
			// true if key is a number or a special key
			if(event.key.match(/[0-9]/) || specialkeys.includes(event.key)) return true;
			event.preventDefault();
			return false;
		}
		function setBckFilename(x) {
			x.setAttribute("download","wled_" + x.getAttribute("download") + (sd=="WLED"?"":("_" +sd)));
		}
		function S() {
			getLoc();
			if (loc) {
				gId("bckcfg").setAttribute('href',getURL(gId("bckcfg").pathname));
				gId("bckpresets").setAttribute('href',getURL(gId("bckpresets").pathname));
			}
			loadJS(getURL('/settings/s.js?p=6'), false, undefined, ()=>{
				setBckFilename(gId("bckcfg"));
				setBckFilename(gId("bckpresets"));
				updateAutoUpdateStatus();
			});	// If we set async false, file is loaded and executed, then next statement is processed
			if (loc) d.Sf.action = getURL('/settings/sec');
		}
		function requestJson(command, callback) {
			var type = command ? 'POST' : 'GET';
			var body = command ? JSON.stringify(command) : null;
			fetch(getURL('/json/si'), {
				method: type,
				headers: {"Content-Type": "application/json; charset=UTF-8"},
				body: body
			})
			.then(res => {
				if (!res.ok) {
					if (callback) callback(null);
					return null;
				}
				return res.json();
			})
			.then(json => {
				if (callback) callback(json);
			})
			.catch((e) => {
				console.error("requestJson error:", e);
				if (callback) callback(null);
			});
		}
		var updateCheckInterval = null;
		var updateCheckTimeout = null;
		
		function checkUpdate() {
			const statusDiv = gId("autoUpdateStatus");
			if (!statusDiv) return;
			
			// 清除之前的轮询
			if (updateCheckInterval) {
				clearInterval(updateCheckInterval);
				updateCheckInterval = null;
			}
			if (updateCheckTimeout) {
				clearTimeout(updateCheckTimeout);
				updateCheckTimeout = null;
			}
			
			statusDiv.innerHTML = "正在检查更新...";
			
			// 发送检查更新请求
			requestJson({"autoUpdate": {"checkUpdate": true}}, function(obj) {
				// 开始轮询状态，每500ms查询一次
				var pollCount = 0;
				var maxPolls = 60; // 最多轮询60次（30秒）
				
				updateCheckInterval = setInterval(function() {
					pollCount++;
					updateAutoUpdateStatus(function(isChecking) {
						// 如果检查完成（状态不再是"正在检查更新..."），停止轮询
						if (!isChecking || pollCount >= maxPolls) {
							if (updateCheckInterval) {
								clearInterval(updateCheckInterval);
								updateCheckInterval = null;
							}
							if (pollCount >= maxPolls) {
								const statusDiv = gId("autoUpdateStatus");
								if (statusDiv && statusDiv.innerHTML.indexOf("正在检查更新...") >= 0) {
									statusDiv.innerHTML = "<strong>状态:</strong> 检查超时，请稍后重试";
								}
							}
						}
					});
				}, 500);
				
				// 设置超时，30秒后强制停止轮询
				updateCheckTimeout = setTimeout(function() {
					if (updateCheckInterval) {
						clearInterval(updateCheckInterval);
						updateCheckInterval = null;
					}
				}, 30000);
			});
		}
		
		function updateAutoUpdateStatus(callback) {
			requestJson(null, function(obj) {
				if (!obj) {
					if (callback) callback(false);
					return;
				}
				
				// /json/si 返回 {state: {...}, info: {...}}
				// autoUpdate 在 state 对象中（serializeState函数中创建）
				var autoUpdate = null;
				if (obj.state && obj.state.autoUpdate) {
					autoUpdate = obj.state.autoUpdate;
				} else if (obj.info && obj.info.autoUpdate) {
					// 兼容info中的autoUpdate
					autoUpdate = obj.info.autoUpdate;
				} else if (obj.autoUpdate) {
					// 兼容直接访问
					autoUpdate = obj.autoUpdate;
				}
				
				if (!autoUpdate) {
					if (callback) callback(false);
					return;
				}
				
				const statusDiv = gId("autoUpdateStatus");
				if (!statusDiv) {
					if (callback) callback(false);
					return;
				}
				
				var status = autoUpdate.status || "未知";
				var isChecking = status.indexOf("正在检查更新") >= 0 || status.indexOf("检查更新") >= 0;
				
				let html = "<strong>状态:</strong> " + status;
				if (autoUpdate.latestVersion) {
					html += "<br><strong>最新版本:</strong> " + autoUpdate.latestVersion;
				}
				if (autoUpdate.currentVersion) {
					html += "<br><strong>当前版本:</strong> " + autoUpdate.currentVersion;
				}
				statusDiv.innerHTML = html;
				
				if (callback) callback(isChecking);
			});
		}
	</script>
	<style>
		@import url("style.css");
	</style>
</head>
<body onload="S()">
	<form id="form_s" name="Sf" method="post">
		<div class="toprow">
		<div class="helpB"><button type="button" onclick="H('features/settings/#security-settings')">?</button></div>
		<button type="button" onclick="B()">返回</button><button type="submit">保存</button><hr>
		</div>
		<h2>安全与更新设置</h2>
		设置PIN码: <input type="password" id="PIN" name="PIN" size="4" maxlength="4" minlength="4" onkeydown="checkNum(this)" pattern="[0-9]*" inputmode="numeric" title="请输入4位数字"><br>
		<div class="warn">&#9888; 未加密传输。选择PIN码时请谨慎，不要使用您的银行、门禁、SIM卡等PIN码！</div><br>
		锁定无线(OTA)软件更新: <input type="checkbox" name="NO"><br>
		密码短语: <input type="password" name="OP" maxlength="32"><br>
		要启用OTA，出于安全原因，您还需要输入正确的密码！<br>
		启用OTA时应更改密码。<br>
		<b>不使用时请禁用OTA，否则攻击者可以重新刷写设备软件！</b><br>
		<i>此页面上的设置仅在OTA锁定禁用时才能更改！</i><br>
		锁定后拒绝访问WiFi设置: <input type="checkbox" name="OW"><br><br>
		恢复出厂设置: <input type="checkbox" name="RS"><br>
		所有设置和预设将被清除。<br><br>
		<div class="warn">&#9888; 未加密传输。同一网络上的攻击者可以拦截表单数据！</div>
		<span id="OTA"><hr>
		<h3>软件更新</h3>
		<button type="button" onclick="U()">手动OTA更新</button><br>
		<div id="aOTA">启用ArduinoOTA: <input type="checkbox" name="AO"></div>
		仅允许从同一网络/WiFi更新: <input type="checkbox" name="SU"><br>
		<i class="warn">&#9888; 如果您使用多个VLAN（即IoT或访客网络），请设置PIN码或禁用此选项。<br>
			禁用此选项将使您的设备安全性降低。</i><br>
		<hr>
		<h3>自动更新</h3>
		启用自动检查更新: <input type="checkbox" name="AU"><br>
		发现新版本时自动安装: <input type="checkbox" name="AI"><br>
		检查间隔（毫秒，最小3600000=1小时）: <input type="number" name="UI" min="3600000" max="86400000" step="3600000"><br>
		GitHub仓库所有者: <input type="text" name="RO" maxlength="32" placeholder="vvlang"><br>
		GitHub仓库名称: <input type="text" name="RN" maxlength="32" placeholder="WLED"><br>
		<div id="autoUpdateStatus" style="margin-top:10px; padding:5px; background:#f0f0f0; border-radius:3px;"></div>
		<button type="button" onclick="checkUpdate()" style="margin-top:10px;">立即检查更新</button><br>
		<i class="warn">&#9888; 自动更新功能会定期从GitHub检查新版本。请确保仓库地址正确。</i><br></span>
		<hr id="backup">
		<h3>备份与恢复</h3>
		<div class="warn">&#9888; 恢复预设/配置将覆盖您当前的预设/配置。<br>
		错误的上传或配置可能需要恢复出厂设置或重新刷写ESP。<br>
		出于安全原因，密码不会被备份。</div>
		<a class="btn lnk" id="bckcfg" href="/presets.json" download="presets">备份预设</a><br>
		<div>恢复预设<br><input type="file" name="data" accept=".json"> <button type="button" onclick="uploadFile(d.Sf.data,'/presets.json');">上传</button><br></div><br>
		<a class="btn lnk" id="bckpresets" href="/cfg.json" download="cfg">备份配置</a><br>
		<div>恢复配置<br><input type="file" name="data2" accept=".json"> <button type="button" onclick="uploadFile(d.Sf.data2,'/cfg.json');">上传</button><br></div>
		<hr>
		<h3>关于</h3>
		<a href="https://github.com/wled-dev/WLED/" target="_blank">WLED</a>&#32;版本 ##VERSION##<!-- Autoreplaced from package.json --><br><br>
		<a href="https://kno.wled.ge/about/contributors/" target="_blank">贡献者、依赖项和特别感谢</a><br>
		非常感谢所有帮助我创建WLED的人！<br><br>
		(c) 2016-2024 Christian Schwinne <br>
		<i>根据 <a href="https://github.com/wled-dev/WLED/blob/main/LICENSE" target="_blank">EUPL v1.2许可证</a>授权</i><br><br>
		已安装版本: <span class="sip">WLED ##VERSION##</span><hr>
		<div id="toast"></div>
		<button type="button" onclick="B()">返回</button><button type="submit">保存</button>
	</form>
</body>
</html>
